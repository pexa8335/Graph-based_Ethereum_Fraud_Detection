import os
import requests
import networkx as nx
import matplotlib.pyplot as plt
import asyncio
import aiohttp
from dotenv import load_dotenv
from tqdm.asyncio import tqdm
from typing import List, Dict, Any, Optional
import matplotlib.lines as mlines
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import math
from datetime import datetime
import pandas as pd
import io
import zipfile

# --- FastAPI Imports ---
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from starlette.responses import StreamingResponse

# --- C·∫§U H√åNH ---
load_dotenv()
FRAUD_API_URL = "https://fraudgraphml-2nz2.onrender.com/analyze"
ETHERSCAN_API_URL = "https://api.etherscan.io/api"
ETHERSCAN_API_KEY = os.getenv("ETHERSCAN_API_KEY")

SUSPICIOUS_LOWER_BOUND = 0.45
SUSPICIOUS_UPPER_BOUND = 0.55
SEMAPHORE = asyncio.Semaphore(1)

# --- KH·ªûI T·∫†O ·ª®NG D·ª§NG FastAPI ---
app = FastAPI(
    title="Ethereum Transaction Graph API",
    description="M·ªôt API ƒë·ªÉ ph√¢n t√≠ch c√°c giao d·ªãch c·ªßa m·ªôt ƒë·ªãa ch·ªâ v√≠ Ethereum, t·∫°o b√°o c√°o CSV v√† bi·ªÉu ƒë·ªì m·∫°ng l∆∞·ªõi.",
    version="1.0.0"
)


# --- M√î H√åNH D·ªÆ LI·ªÜU ƒê·∫¶U V√ÄO (Pydantic) ---
class AnalysisRequest(BaseModel):
    address: str


# --- C√ÅC H√ÄM X·ª¨ L√ù ---
async def get_fraud_prediction(session: aiohttp.ClientSession, address: str) -> Optional[Dict[str, Any]]:
    """G·ª≠i y√™u c·∫ßu d·ª± ƒëo√°n ƒë·∫øn API c·ª•c b·ªô, ƒë∆∞·ª£c ki·ªÉm so√°t b·ªüi Semaphore."""
    async with SEMAPHORE:
        await asyncio.sleep(1.5)
        payload = {"address": address}
        try:
            async with session.post(FRAUD_API_URL, json=payload, timeout=300) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    error_text = await response.text()
                    print(
                        f"L·ªói khi d·ª± ƒëo√°n ƒë·ªãa ch·ªâ {address[:10]}...: Status {response.status}, Response: {error_text[:150]}")
                    return None
        except asyncio.TimeoutError:
            print(f"Timeout khi d·ª± ƒëo√°n ƒë·ªãa ch·ªâ {address[:10]}...")
            return None
        except Exception as e:
            print(f"Ngo·∫°i l·ªá kh√¥ng x√°c ƒë·ªãnh khi d·ª± ƒëo√°n {address[:10]}: {e}")
            return None


def get_transactions(address: str) -> List[Dict[str, Any]]:
    print(f"\nüîç ƒêang l·∫•y giao d·ªãch cho ƒë·ªãa ch·ªâ: {address}")
    params = {
        "module": "account", "action": "txlist", "address": address,
        "startblock": 0, "endblock": 99999999, "sort": "asc", "apikey": ETHERSCAN_API_KEY
    }
    try:
        response = requests.get(ETHERSCAN_API_URL, params=params)
        response.raise_for_status()
        data = response.json()
        if data["status"] == "1":
            print(f"‚úÖ T√¨m th·∫•y {len(data['result'])} giao d·ªãch.")
            return data["result"]
        else:
            print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y giao d·ªãch ho·∫∑c c√≥ l·ªói t·ª´ API: {data['message']}")
            return []
    except requests.exceptions.RequestException as e:
        print(f"L·ªói khi g·ªçi Etherscan API: {e}")
        return []


def export_transactions_to_csv_buffer(transactions: List[Dict[str, Any]],
                                      predictions: Dict[str, Dict[str, Any]],
                                      central_address: str) -> io.StringIO:
    """
    L√†m gi√†u d·ªØ li·ªáu giao d·ªãch v·ªõi th√¥ng tin chi ti·∫øt, d·ª± ƒëo√°n v√† c√°c tr∆∞·ªùng ph√¢n t√≠ch,
    sau ƒë√≥ xu·∫•t ra m·ªôt buffer CSV trong b·ªô nh·ªõ.
    """
    print(f"\nüìÑ ƒêang l√†m gi√†u d·ªØ li·ªáu v√† t·∫°o buffer CSV chi ti·∫øt...")
    processed_data = []
    central_address_lower = central_address.lower()

    def get_prediction_data(addr):
        if not addr:
            return 'Contract Creation', 0.0
        pred_result = predictions.get(addr.lower())
        if pred_result:
            return pred_result.get('prediction', 'Unknown'), pred_result.get('probability_fraud', 0.0)
        return 'Not Predicted', 0.0

    for tx in transactions:
        from_addr = tx.get('from', '').lower()
        to_addr = tx.get('to', '').lower()

        if not from_addr:
            continue

        from_pred, from_prob = get_prediction_data(from_addr)
        to_pred, to_prob = get_prediction_data(to_addr)

        # C·∫£i thi·ªán ƒëi·ªÉm r·ªßi ro
        transaction_risk_score = from_prob + to_prob

        # Chuy·ªÉn ƒë·ªïi gi√° tr·ªã v√† th·ªùi gian
        value_in_eth = int(tx.get('value', 0)) / 1e18
        timestamp = int(tx.get('timeStamp', 0))
        date_time_utc = datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')

        # --- C√ÅC C·ªòT M·ªöI ƒê∆Ø·ª¢C TH√äM V√ÄO ---
        gas_used = int(tx.get('gasUsed', 0))
        gas_price_wei = int(tx.get('gasPrice', 0))
        transaction_fee_eth = (gas_used * gas_price_wei) / 1e18
        gas_price_gwei = gas_price_wei / 1e9

        # X√°c ƒë·ªãnh chi·ªÅu giao d·ªãch
        if from_addr == central_address_lower:
            direction = 'Outgoing'
        elif to_addr == central_address_lower:
            direction = 'Incoming'
        else:
            direction = 'Indirect'  # Giao d·ªãch gi·ªØa 2 ƒë·ªãa ch·ªâ kh√°c trong list

        transaction_status = 'Success' if tx.get('isError') == '0' else 'Failed'
        is_contract_creation = True if not to_addr else False
        etherscan_url = f"https://etherscan.io/tx/{tx.get('hash', '')}"

        processed_data.append({
            'transaction_hash': tx.get('hash', ''),
            'timestamp_utc': date_time_utc,
            'block_number': tx.get('blockNumber', ''),
            'direction': direction,
            'from_address': from_addr,
            'to_address': to_addr if to_addr else "Contract Creation",
            'value_eth': value_in_eth,
            # 'value_usd_at_time': C·∫ßn API gi√° l·ªãch s·ª≠ ƒë·ªÉ th√™m c·ªôt n√†y
            'transaction_fee_eth': round(transaction_fee_eth, 12),
            'transaction_status': transaction_status,
            'gas_price_gwei': round(gas_price_gwei, 2),
            'gas_used': gas_used,
            'is_contract_creation': is_contract_creation,
            'from_address_prediction': from_pred,
            'from_address_fraud_probability': from_prob,
            'to_address_prediction': to_pred,
            'to_address_fraud_probability': to_prob,
            'transaction_risk_score': transaction_risk_score,
            'etherscan_url': etherscan_url
        })

    if not processed_data:
        print("‚ö†Ô∏è Kh√¥ng c√≥ giao d·ªãch n√†o ƒë·ªÉ xu·∫•t.")
        return io.StringIO()

    # S·∫Øp x·∫øp theo ƒëi·ªÉm r·ªßi ro gi·∫£m d·∫ßn
    df = pd.DataFrame(processed_data)
    df = df.sort_values(by='transaction_risk_score', ascending=False)

    csv_buffer = io.StringIO()
    df.to_csv(csv_buffer, index=False, encoding='utf-8-sig')
    csv_buffer.seek(0)
    print(f"‚úÖ ƒê√£ t·∫°o th√†nh c√¥ng buffer CSV chi ti·∫øt v·ªõi {len(df)} h√†ng v√† {len(df.columns)} c·ªôt.")
    return csv_buffer


def get_node_color(prediction_result: Optional[Dict[str, Any]]) -> str:
    if not prediction_result: return 'grey'
    prob = prediction_result.get('probability_fraud', -1.0)
    pred_text = prediction_result.get('prediction', '').lower().strip()
    if SUSPICIOUS_LOWER_BOUND < prob < SUSPICIOUS_UPPER_BOUND: return '#F0E68C'
    if pred_text == 'fraud' or pred_text == 'illicit': return '#990000'
    if pred_text == 'non-fraud' or pred_text == 'licit': return '#000066'
    return 'grey'


def fibonacci_sphere(samples: int):
    points = [];
    phi = math.pi * (math.sqrt(5.) - 1.)
    for i in range(samples):
        y = 1 - (i / float(samples - 1)) * 2;
        radius = math.sqrt(1 - y * y)
        theta = phi * i;
        x = math.cos(theta) * radius;
        z = math.sin(theta) * radius
        points.append((x, y, z))
    return points


def draw_transaction_graph_to_buffer(central_address: str, transactions: List[Dict[str, Any]],
                                     predictions: Dict[str, Dict]) -> Optional[io.BytesIO]:
    print("\nüé® ƒêang v·∫Ω bi·ªÉu ƒë·ªì h√¨nh c·∫ßu 3D v√†o buffer...")
    central_address = central_address.lower()
    G = nx.DiGraph()
    direct_transactions = [tx for tx in transactions if
                           tx.get('from', '').lower() == central_address or tx.get('to', '').lower() == central_address]
    G.add_node(central_address)
    for tx in direct_transactions:
        from_addr, to_addr = tx.get('from', '').lower(), tx.get('to', '').lower()
        if from_addr and to_addr: G.add_edge(from_addr, to_addr)
    if G.number_of_nodes() <= 1:
        print("Kh√¥ng ƒë·ªß node ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì.");
        return None
    num_nodes = G.number_of_nodes()
    other_nodes = [node for node in G.nodes() if node != central_address]
    nodes_in_order = [central_address] + other_nodes
    pos = {node: fibonacci_sphere(num_nodes)[i] for i, node in enumerate(nodes_in_order)}
    fig = plt.figure(figsize=(15, 15));
    ax = fig.add_subplot(111, projection='3d');
    fig.set_facecolor('white')
    node_colors = [get_node_color(predictions.get(node)) for node in nodes_in_order]
    node_sizes = [500 if node == central_address else 150 for node in nodes_in_order]
    xyz = np.array([pos[v] for v in nodes_in_order])
    ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], c=node_colors, s=node_sizes, edgecolors='black', linewidths=0.5,
               alpha=1.0)
    for edge in G.edges():
        start_pos, end_pos = pos[edge[0]], pos[edge[1]]
        ax.plot([start_pos[0], end_pos[0]], [start_pos[1], end_pos[1]], [start_pos[2], end_pos[2]], color='gray',
                alpha=0.5, linewidth=1.2)
    legend_handles = [mlines.Line2D([], [], color=color, marker='o', linestyle='None', markersize=10, label=label)
                      for label, color in {'Gian l·∫≠n (Illicit)': '#990000', 'An to√†n (Licit)': '#000066',
                                           'Nghi ng·ªù (Suspicious)': '#F0E68C', 'Kh√¥ng x√°c ƒë·ªãnh': 'grey'}.items()]
    ax.legend(handles=legend_handles, loc='upper right', title='Node Status');
    ax.set_axis_off();
    ax.set_title(f"Transaction Graph of: {central_address}", fontsize=18);
    plt.tight_layout();
    ax.view_init(elev=5, azim=90)
    image_buffer = io.BytesIO();
    plt.savefig(image_buffer, format='png', dpi=300, bbox_inches='tight');
    plt.close(fig);
    image_buffer.seek(0)
    print("‚úÖ ƒê√£ l∆∞u th√†nh c√¥ng bi·ªÉu ƒë·ªì v√†o buffer.")
    return image_buffer


# --- API ENDPOINT ---
@app.post("/graph")
async def create_graph_analysis(request: AnalysisRequest):
    if not ETHERSCAN_API_KEY:
        raise HTTPException(status_code=500,
                            detail="L·ªñI: Bi·∫øn m√¥i tr∆∞·ªùng ETHERSCAN_API_KEY ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p tr√™n m√°y ch·ªß.")
    central_address = request.address.strip()
    if not central_address:
        raise HTTPException(status_code=400, detail="ƒê·ªãa ch·ªâ kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")
    transactions = get_transactions(central_address)
    if not transactions:
        raise HTTPException(status_code=404, detail=f"Kh√¥ng t√¨m th·∫•y giao d·ªãch n√†o cho ƒë·ªãa ch·ªâ: {central_address}")

    unique_addresses = {addr.lower() for tx in transactions for addr in [tx.get('from', ''), tx.get('to', '')] if addr}
    unique_addresses.add(central_address.lower())

    all_addresses_list = list(unique_addresses)
    print(f"\nüî¨ T√¨m th·∫•y {len(all_addresses_list)} ƒë·ªãa ch·ªâ duy nh·∫•t. B·∫Øt ƒë·∫ßu d·ª± ƒëo√°n...")

    predictions = {}
    addresses_to_retry = list(all_addresses_list)

    # ‚≠ê THAY ƒê·ªîI: Th√™m logic ƒë·∫øm l·ªói cho t·ª´ng ƒë·ªãa ch·ªâ
    failure_counts = {addr: 0 for addr in all_addresses_list}
    MAX_INDIVIDUAL_RETRIES = 7  # Gi·ªõi h·∫°n s·ªë l·∫ßn th·ª≠ l·∫°i cho M·ªñI ƒë·ªãa ch·ªâ

    retry_round = 1
    base_retry_delay = 5

    while addresses_to_retry:
        if retry_round > 1:
            retry_delay = base_retry_delay * (retry_round - 1)
            print(
                f"\n- V√íNG TH·ª¨ L·∫†I {retry_round - 1}: Ph√°t hi·ªán {len(addresses_to_retry)} ƒë·ªãa ch·ªâ b·ªã l·ªói. ƒêang th·ª≠ l·∫°i sau {retry_delay}s...")
            await asyncio.sleep(retry_delay)

        desc = f"ƒêang d·ª± ƒëo√°n (v√≤ng {retry_round})"
        async with aiohttp.ClientSession() as session:
            tasks = [get_fraud_prediction(session, addr) for addr in addresses_to_retry]
            results = await tqdm.gather(*tasks, desc=desc)

        successful_addrs_this_round = set()
        for res in results:
            if res and 'address' in res:
                addr = res['address'].lower()
                predictions[addr] = res
                successful_addrs_this_round.add(addr)

        current_failures = [addr for addr in addresses_to_retry if addr not in successful_addrs_this_round]

        # ‚≠ê THAY ƒê·ªîI: Lo·∫°i b·ªè nh·ªØng ƒë·ªãa ch·ªâ ƒë√£ th·∫•t b·∫°i qu√° nhi·ªÅu l·∫ßn
        next_round_addresses = []
        for addr in current_failures:
            failure_counts[addr] += 1
            if failure_counts[addr] < MAX_INDIVIDUAL_RETRIES:
                next_round_addresses.append(addr)
            else:
                print(f"‚ö†Ô∏è ƒê√£ t·ª´ b·ªè ƒë·ªãa ch·ªâ {addr[:10]}... sau {failure_counts[addr]} l·∫ßn th·ª≠ th·∫•t b·∫°i.")

        addresses_to_retry = next_round_addresses

        if not addresses_to_retry:
            break
        retry_round += 1

    if any(count >= MAX_INDIVIDUAL_RETRIES for count in failure_counts.values()):
        print(f"\n‚ö†Ô∏è C·∫¢NH B√ÅO: M·ªôt s·ªë ƒë·ªãa ch·ªâ kh√¥ng th·ªÉ d·ª± ƒëo√°n ƒë∆∞·ª£c sau {MAX_INDIVIDUAL_RETRIES} l·∫ßn th·ª≠.")

    print("\n‚úÖ D·ª± ƒëo√°n ho√†n t·∫•t!")

    csv_buffer = export_transactions_to_csv_buffer(transactions, predictions, central_address)
    image_buffer = draw_transaction_graph_to_buffer(central_address, transactions, predictions)

    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
        zf.writestr("enriched_transactions.csv", csv_buffer.getvalue())
        if image_buffer:
            zf.writestr("transaction_graph.png", image_buffer.getvalue())
    zip_buffer.seek(0)

    headers = {'Content-Disposition': f'attachment; filename="analysis_results_{central_address[:10]}.zip"'}
    return StreamingResponse(zip_buffer, media_type="application/x-zip-compressed", headers=headers)


# --- KH·ªêI ƒê·ªÇ CH·∫†Y M√ÅY CH·ª¶ ---
if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="127.0.0.1", port=8001)